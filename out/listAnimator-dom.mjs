/* generated by Svelte v3.23.2 */
import {
  SvelteComponent,
  add_render_callback,
  append,
  children,
  claim_element,
  claim_space,
  claim_text,
  create_in_transition,
  destroy_block,
  detach,
  element,
  empty,
  init,
  insert,
  noop,
  safe_not_equal,
  set_data,
  space,
  text,
  transition_in,
  update_keyed_each,
} from "/js/svelte/internal/index.mjs";

import { onMount } from "/js/svelte/internal/index.mjs";
import { fly, slide } from "/js/svelte/transition/index.mjs";

function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}

// (37:0) { #each items as item (item) }
function create_each_block(key_1, ctx) {
  let div;
  let button;
  let t0_value = /*item*/ ctx[7] + "";
  let t0;
  let t1;
  let div_intro;

  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      button = claim_element(div_nodes, "BUTTON", {});
      var button_nodes = children(button);
      t0 = claim_text(button_nodes, t0_value);
      button_nodes.forEach(detach);
      t1 = claim_space(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, t0);
      append(div, t1);
    },
    p(ctx, dirty) {
      if (
        dirty & /*items*/ 1 && t0_value !== (t0_value = /*item*/ ctx[7] + "")
      ) {
        set_data(t0, t0_value);
      }
    },
    i(local) {
      if (!div_intro) {
        add_render_callback(() => {
          div_intro = create_in_transition(div, /*intro*/ ctx[1], {});
          div_intro.start();
        });
      }
    },
    o: noop,
    d(detaching) {
      if (detaching) detach(div);
    },
  };
}

function create_fragment(ctx) {
  let each_blocks = [];
  let each_1_lookup = new Map();
  let each_1_anchor;
  let each_value = /*items*/ ctx[0];
  const get_key = (ctx) => /*item*/ ctx[7];

  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }

  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }

      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }

      insert(target, each_1_anchor, anchor);
    },
    p(ctx, [dirty]) {
      if (dirty & /*items*/ 1) {
        const each_value = /*items*/ ctx[0];
        each_blocks = update_keyed_each(
          each_blocks,
          dirty,
          get_key,
          1,
          ctx,
          each_value,
          each_1_lookup,
          each_1_anchor.parentNode,
          destroy_block,
          create_each_block,
          each_1_anchor,
          get_each_context,
        );
      }
    },
    i(local) {
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
    },
    o: noop,
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }

      if (detaching) detach(each_1_anchor);
    },
  };
}

function instance($$self, $$props, $$invalidate) {
  let { effect = { name: "slide", conf: { duration: 250 } } } = $$props;
  let next = 0, items = [], intervalId = undefined;
  const effects = { fly, slide };
  const intro = (node) => effects[effect.name](node, effect.conf);

  const incrementItems = () => {
    if (next > 80) {
      clearInterval(intervalId);
    }

    $$invalidate(0, items = [next++, ...items]);
  };

  onMount(() => {
    intervalId = setInterval(incrementItems, 250);

    window.addEventListener("focus", () => {
      if (!intervalId) {
        intervalId = setInterval(incrementItems, 250);
      }
    });

    window.addEventListener("blur", () => {
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = undefined;
      }
    });

    $$invalidate(0, items = [next++, ...items]);
  });

  $$self.$set = ($$props) => {
    if ("effect" in $$props) $$invalidate(2, effect = $$props.effect);
  };

  return [items, intro, effect];
}

class ListAnimator extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      { effect: 2 },
    );
  }
}

export default ListAnimator;
